# coding: utf-8

"""
    weather.gov API

    weather.gov API  # noqa: E501

    OpenAPI spec version: 1.8.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def alerts_active(self, **kwargs):  # noqa: E501
        """alerts_active  # noqa: E501

        Returns all currently active alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] status: Status (actual, exercise, system, test, draft)
        :param list[str] message_type: Message type (alert, update, cancel)
        :param list[str] event: Event name
        :param list[str] code: Event code
        :param list[AreaCode] area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
        :param PointString point: Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
        :param list[MarineRegionCode] region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
        :param str region_type: Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
        :param list[NWSZoneID] zone: Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
        :param list[AlertUrgency] urgency: Urgency (immediate, expected, future, past, unknown)
        :param list[AlertSeverity] severity: Severity (extreme, severe, moderate, minor, unknown)
        :param list[AlertCertainty] certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :param int limit: Limit
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.alerts_active_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.alerts_active_with_http_info(**kwargs)  # noqa: E501
            return data

    def alerts_active_with_http_info(self, **kwargs):  # noqa: E501
        """alerts_active  # noqa: E501

        Returns all currently active alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] status: Status (actual, exercise, system, test, draft)
        :param list[str] message_type: Message type (alert, update, cancel)
        :param list[str] event: Event name
        :param list[str] code: Event code
        :param list[AreaCode] area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
        :param PointString point: Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
        :param list[MarineRegionCode] region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
        :param str region_type: Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
        :param list[NWSZoneID] zone: Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
        :param list[AlertUrgency] urgency: Urgency (immediate, expected, future, past, unknown)
        :param list[AlertSeverity] severity: Severity (extreme, severe, moderate, minor, unknown)
        :param list[AlertCertainty] certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :param int limit: Limit
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['status', 'message_type', 'event', 'code', 'area', 'point', 'region', 'region_type', 'zone', 'urgency', 'severity', 'certainty', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'message_type' in params:
            query_params.append(('message_type', params['message_type']))  # noqa: E501
            collection_formats['message_type'] = 'csv'  # noqa: E501
        if 'event' in params:
            query_params.append(('event', params['event']))  # noqa: E501
            collection_formats['event'] = 'csv'  # noqa: E501
        if 'code' in params:
            query_params.append(('code', params['code']))  # noqa: E501
            collection_formats['code'] = 'csv'  # noqa: E501
        if 'area' in params:
            query_params.append(('area', params['area']))  # noqa: E501
            collection_formats['area'] = 'csv'  # noqa: E501
        if 'point' in params:
            query_params.append(('point', params['point']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'region_type' in params:
            query_params.append(('region_type', params['region_type']))  # noqa: E501
        if 'zone' in params:
            query_params.append(('zone', params['zone']))  # noqa: E501
            collection_formats['zone'] = 'csv'  # noqa: E501
        if 'urgency' in params:
            query_params.append(('urgency', params['urgency']))  # noqa: E501
            collection_formats['urgency'] = 'csv'  # noqa: E501
        if 'severity' in params:
            query_params.append(('severity', params['severity']))  # noqa: E501
            collection_formats['severity'] = 'csv'  # noqa: E501
        if 'certainty' in params:
            query_params.append(('certainty', params['certainty']))  # noqa: E501
            collection_formats['certainty'] = 'csv'  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlertCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alerts_active_area(self, area, **kwargs):  # noqa: E501
        """alerts_active_area  # noqa: E501

        Returns active alerts for the given area (state or marine area)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_area(area, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AreaCode area: State/area ID (required)
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.alerts_active_area_with_http_info(area, **kwargs)  # noqa: E501
        else:
            (data) = self.alerts_active_area_with_http_info(area, **kwargs)  # noqa: E501
            return data

    def alerts_active_area_with_http_info(self, area, **kwargs):  # noqa: E501
        """alerts_active_area  # noqa: E501

        Returns active alerts for the given area (state or marine area)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_area_with_http_info(area, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AreaCode area: State/area ID (required)
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['area']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_area" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'area' is set
        if ('area' not in params or
                params['area'] is None):
            raise ValueError("Missing the required parameter `area` when calling `alerts_active_area`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'area' in params:
            path_params['area'] = params['area']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active/area/{area}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlertCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alerts_active_count(self, **kwargs):  # noqa: E501
        """alerts_active_count  # noqa: E501

        Returns info on the number of active alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.alerts_active_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.alerts_active_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def alerts_active_count_with_http_info(self, **kwargs):  # noqa: E501
        """alerts_active_count  # noqa: E501

        Returns info on the number of active alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alerts_active_region(self, region, **kwargs):  # noqa: E501
        """alerts_active_region  # noqa: E501

        Returns active alerts for the given marine region  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_region(region, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MarineRegionCode region: Marine region ID (required)
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.alerts_active_region_with_http_info(region, **kwargs)  # noqa: E501
        else:
            (data) = self.alerts_active_region_with_http_info(region, **kwargs)  # noqa: E501
            return data

    def alerts_active_region_with_http_info(self, region, **kwargs):  # noqa: E501
        """alerts_active_region  # noqa: E501

        Returns active alerts for the given marine region  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_region_with_http_info(region, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MarineRegionCode region: Marine region ID (required)
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['region']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_region" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'region' is set
        if ('region' not in params or
                params['region'] is None):
            raise ValueError("Missing the required parameter `region` when calling `alerts_active_region`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'region' in params:
            path_params['region'] = params['region']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active/region/{region}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlertCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alerts_active_zone(self, zone_id, **kwargs):  # noqa: E501
        """alerts_active_zone  # noqa: E501

        Returns active alerts for the given NWS public zone or county  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_zone(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.alerts_active_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.alerts_active_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def alerts_active_zone_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """alerts_active_zone  # noqa: E501

        Returns active alerts for the given NWS public zone or county  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_active_zone_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `alerts_active_zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zoneId'] = params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active/zone/{zoneId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlertCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alerts_query(self, **kwargs):  # noqa: E501
        """alerts_query  # noqa: E501

        Returns all alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_query(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool active: List only active alerts (use /alerts/active endpoints instead)
        :param datetime start: Start time
        :param datetime end: End time
        :param list[str] status: Status (actual, exercise, system, test, draft)
        :param list[str] message_type: Message type (alert, update, cancel)
        :param list[str] event: Event name
        :param list[str] code: Event code
        :param list[AreaCode] area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
        :param PointString point: Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
        :param list[MarineRegionCode] region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
        :param str region_type: Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
        :param list[NWSZoneID] zone: Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
        :param list[AlertUrgency] urgency: Urgency (immediate, expected, future, past, unknown)
        :param list[AlertSeverity] severity: Severity (extreme, severe, moderate, minor, unknown)
        :param list[AlertCertainty] certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :param int limit: Limit
        :param str cursor: Pagination cursor
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.alerts_query_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.alerts_query_with_http_info(**kwargs)  # noqa: E501
            return data

    def alerts_query_with_http_info(self, **kwargs):  # noqa: E501
        """alerts_query  # noqa: E501

        Returns all alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_query_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool active: List only active alerts (use /alerts/active endpoints instead)
        :param datetime start: Start time
        :param datetime end: End time
        :param list[str] status: Status (actual, exercise, system, test, draft)
        :param list[str] message_type: Message type (alert, update, cancel)
        :param list[str] event: Event name
        :param list[str] code: Event code
        :param list[AreaCode] area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
        :param PointString point: Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
        :param list[MarineRegionCode] region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
        :param str region_type: Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
        :param list[NWSZoneID] zone: Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
        :param list[AlertUrgency] urgency: Urgency (immediate, expected, future, past, unknown)
        :param list[AlertSeverity] severity: Severity (extreme, severe, moderate, minor, unknown)
        :param list[AlertCertainty] certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :param int limit: Limit
        :param str cursor: Pagination cursor
        :return: AlertCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['active', 'start', 'end', 'status', 'message_type', 'event', 'code', 'area', 'point', 'region', 'region_type', 'zone', 'urgency', 'severity', 'certainty', 'limit', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_query" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'active' in params:
            query_params.append(('active', params['active']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'message_type' in params:
            query_params.append(('message_type', params['message_type']))  # noqa: E501
            collection_formats['message_type'] = 'csv'  # noqa: E501
        if 'event' in params:
            query_params.append(('event', params['event']))  # noqa: E501
            collection_formats['event'] = 'csv'  # noqa: E501
        if 'code' in params:
            query_params.append(('code', params['code']))  # noqa: E501
            collection_formats['code'] = 'csv'  # noqa: E501
        if 'area' in params:
            query_params.append(('area', params['area']))  # noqa: E501
            collection_formats['area'] = 'csv'  # noqa: E501
        if 'point' in params:
            query_params.append(('point', params['point']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'region_type' in params:
            query_params.append(('region_type', params['region_type']))  # noqa: E501
        if 'zone' in params:
            query_params.append(('zone', params['zone']))  # noqa: E501
            collection_formats['zone'] = 'csv'  # noqa: E501
        if 'urgency' in params:
            query_params.append(('urgency', params['urgency']))  # noqa: E501
            collection_formats['urgency'] = 'csv'  # noqa: E501
        if 'severity' in params:
            query_params.append(('severity', params['severity']))  # noqa: E501
            collection_formats['severity'] = 'csv'  # noqa: E501
        if 'certainty' in params:
            query_params.append(('certainty', params['certainty']))  # noqa: E501
            collection_formats['certainty'] = 'csv'  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlertCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alerts_single(self, id, **kwargs):  # noqa: E501
        """alerts_single  # noqa: E501

        Returns a specific alert  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_single(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertId id: Alert identifier (required)
        :return: AlertGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.alerts_single_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.alerts_single_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def alerts_single_with_http_info(self, id, **kwargs):  # noqa: E501
        """alerts_single  # noqa: E501

        Returns a specific alert  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_single_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertId id: Alert identifier (required)
        :return: AlertGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_single" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `alerts_single`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/cap+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/alerts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlertGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alerts_types(self, **kwargs):  # noqa: E501
        """alerts_types  # noqa: E501

        Returns a list of alert types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.alerts_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.alerts_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def alerts_types_with_http_info(self, **kwargs):  # noqa: E501
        """alerts_types  # noqa: E501

        Returns a list of alert types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alerts_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/alerts/types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def glossary(self, **kwargs):  # noqa: E501
        """glossary  # noqa: E501

        Returns glossary terms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.glossary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.glossary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.glossary_with_http_info(**kwargs)  # noqa: E501
            return data

    def glossary_with_http_info(self, **kwargs):  # noqa: E501
        """glossary  # noqa: E501

        Returns glossary terms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.glossary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method glossary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/glossary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gridpoint(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoint  # noqa: E501

        Returns raw numerical forecast data for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gridpoint(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId wfo: Forecast office ID (required)
        :param int x: Forecast grid X coordinate (required)
        :param int y: Forecast grid Y coordinate (required)
        :return: GridpointGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gridpoint_with_http_info(wfo, x, y, **kwargs)  # noqa: E501
        else:
            (data) = self.gridpoint_with_http_info(wfo, x, y, **kwargs)  # noqa: E501
            return data

    def gridpoint_with_http_info(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoint  # noqa: E501

        Returns raw numerical forecast data for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gridpoint_with_http_info(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId wfo: Forecast office ID (required)
        :param int x: Forecast grid X coordinate (required)
        :param int y: Forecast grid Y coordinate (required)
        :return: GridpointGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wfo', 'x', 'y']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gridpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wfo' is set
        if ('wfo' not in params or
                params['wfo'] is None):
            raise ValueError("Missing the required parameter `wfo` when calling `gridpoint`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `gridpoint`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `gridpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wfo' in params:
            path_params['wfo'] = params['wfo']  # noqa: E501
        if 'x' in params:
            path_params['x'] = params['x']  # noqa: E501
        if 'y' in params:
            path_params['y'] = params['y']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/gridpoints/{wfo}/{x},{y}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GridpointGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gridpoint_forecast(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoint_forecast  # noqa: E501

        Returns a textual forecast for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gridpoint_forecast(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId wfo: Forecast office ID (required)
        :param int x: Forecast grid X coordinate (required)
        :param int y: Forecast grid Y coordinate (required)
        :param list[str] feature_flags: Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
        :param GridpointForecastUnits units: Use US customary or SI (metric) units in textual output
        :return: GridpointForecastGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gridpoint_forecast_with_http_info(wfo, x, y, **kwargs)  # noqa: E501
        else:
            (data) = self.gridpoint_forecast_with_http_info(wfo, x, y, **kwargs)  # noqa: E501
            return data

    def gridpoint_forecast_with_http_info(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoint_forecast  # noqa: E501

        Returns a textual forecast for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gridpoint_forecast_with_http_info(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId wfo: Forecast office ID (required)
        :param int x: Forecast grid X coordinate (required)
        :param int y: Forecast grid Y coordinate (required)
        :param list[str] feature_flags: Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
        :param GridpointForecastUnits units: Use US customary or SI (metric) units in textual output
        :return: GridpointForecastGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wfo', 'x', 'y', 'feature_flags', 'units']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gridpoint_forecast" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wfo' is set
        if ('wfo' not in params or
                params['wfo'] is None):
            raise ValueError("Missing the required parameter `wfo` when calling `gridpoint_forecast`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `gridpoint_forecast`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `gridpoint_forecast`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wfo' in params:
            path_params['wfo'] = params['wfo']  # noqa: E501
        if 'x' in params:
            path_params['x'] = params['x']  # noqa: E501
        if 'y' in params:
            path_params['y'] = params['y']  # noqa: E501

        query_params = []
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501

        header_params = {}
        if 'feature_flags' in params:
            header_params['Feature-Flags'] = params['feature_flags']  # noqa: E501
            collection_formats['Feature-Flags'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.dwml+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/gridpoints/{wfo}/{x},{y}/forecast', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GridpointForecastGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gridpoint_forecast_hourly(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoint_forecast_hourly  # noqa: E501

        Returns a textual hourly forecast for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gridpoint_forecast_hourly(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId wfo: Forecast office ID (required)
        :param int x: Forecast grid X coordinate (required)
        :param int y: Forecast grid Y coordinate (required)
        :param list[str] feature_flags: Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
        :param GridpointForecastUnits units: Use US customary or SI (metric) units in textual output
        :return: GridpointForecastGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gridpoint_forecast_hourly_with_http_info(wfo, x, y, **kwargs)  # noqa: E501
        else:
            (data) = self.gridpoint_forecast_hourly_with_http_info(wfo, x, y, **kwargs)  # noqa: E501
            return data

    def gridpoint_forecast_hourly_with_http_info(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoint_forecast_hourly  # noqa: E501

        Returns a textual hourly forecast for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gridpoint_forecast_hourly_with_http_info(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId wfo: Forecast office ID (required)
        :param int x: Forecast grid X coordinate (required)
        :param int y: Forecast grid Y coordinate (required)
        :param list[str] feature_flags: Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
        :param GridpointForecastUnits units: Use US customary or SI (metric) units in textual output
        :return: GridpointForecastGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wfo', 'x', 'y', 'feature_flags', 'units']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gridpoint_forecast_hourly" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wfo' is set
        if ('wfo' not in params or
                params['wfo'] is None):
            raise ValueError("Missing the required parameter `wfo` when calling `gridpoint_forecast_hourly`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `gridpoint_forecast_hourly`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `gridpoint_forecast_hourly`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wfo' in params:
            path_params['wfo'] = params['wfo']  # noqa: E501
        if 'x' in params:
            path_params['x'] = params['x']  # noqa: E501
        if 'y' in params:
            path_params['y'] = params['y']  # noqa: E501

        query_params = []
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501

        header_params = {}
        if 'feature_flags' in params:
            header_params['Feature-Flags'] = params['feature_flags']  # noqa: E501
            collection_formats['Feature-Flags'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.dwml+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/gridpoints/{wfo}/{x},{y}/forecast/hourly', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GridpointForecastGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gridpoint_stations(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoint_stations  # noqa: E501

        Returns a list of observation stations usable for a given 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gridpoint_stations(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId wfo: Forecast office ID (required)
        :param int x: Forecast grid X coordinate (required)
        :param int y: Forecast grid Y coordinate (required)
        :return: ObservationStationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gridpoint_stations_with_http_info(wfo, x, y, **kwargs)  # noqa: E501
        else:
            (data) = self.gridpoint_stations_with_http_info(wfo, x, y, **kwargs)  # noqa: E501
            return data

    def gridpoint_stations_with_http_info(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoint_stations  # noqa: E501

        Returns a list of observation stations usable for a given 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gridpoint_stations_with_http_info(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId wfo: Forecast office ID (required)
        :param int x: Forecast grid X coordinate (required)
        :param int y: Forecast grid Y coordinate (required)
        :return: ObservationStationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wfo', 'x', 'y']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gridpoint_stations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wfo' is set
        if ('wfo' not in params or
                params['wfo'] is None):
            raise ValueError("Missing the required parameter `wfo` when calling `gridpoint_stations`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `gridpoint_stations`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `gridpoint_stations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wfo' in params:
            path_params['wfo'] = params['wfo']  # noqa: E501
        if 'x' in params:
            path_params['x'] = params['x']  # noqa: E501
        if 'y' in params:
            path_params['y'] = params['y']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/gridpoints/{wfo}/{x},{y}/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObservationStationCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def icons(self, set, time_of_day, first, **kwargs):  # noqa: E501
        """icons  # noqa: E501

        Returns a forecast icon. Icon services in API are deprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.icons(set, time_of_day, first, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str set: . (required)
        :param str time_of_day: . (required)
        :param str first: . (required)
        :param Size size: Font size
        :param int fontsize: Font size
        :return: BinaryFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.icons_with_http_info(set, time_of_day, first, **kwargs)  # noqa: E501
        else:
            (data) = self.icons_with_http_info(set, time_of_day, first, **kwargs)  # noqa: E501
            return data

    def icons_with_http_info(self, set, time_of_day, first, **kwargs):  # noqa: E501
        """icons  # noqa: E501

        Returns a forecast icon. Icon services in API are deprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.icons_with_http_info(set, time_of_day, first, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str set: . (required)
        :param str time_of_day: . (required)
        :param str first: . (required)
        :param Size size: Font size
        :param int fontsize: Font size
        :return: BinaryFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set', 'time_of_day', 'first', 'size', 'fontsize']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method icons" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set' is set
        if ('set' not in params or
                params['set'] is None):
            raise ValueError("Missing the required parameter `set` when calling `icons`")  # noqa: E501
        # verify the required parameter 'time_of_day' is set
        if ('time_of_day' not in params or
                params['time_of_day'] is None):
            raise ValueError("Missing the required parameter `time_of_day` when calling `icons`")  # noqa: E501
        # verify the required parameter 'first' is set
        if ('first' not in params or
                params['first'] is None):
            raise ValueError("Missing the required parameter `first` when calling `icons`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'set' in params:
            path_params['set'] = params['set']  # noqa: E501
        if 'time_of_day' in params:
            path_params['timeOfDay'] = params['time_of_day']  # noqa: E501
        if 'first' in params:
            path_params['first'] = params['first']  # noqa: E501

        query_params = []
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'fontsize' in params:
            query_params.append(('fontsize', params['fontsize']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/icons/{set}/{timeOfDay}/{first}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BinaryFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def icons_dual_condition(self, set, time_of_day, first, second, **kwargs):  # noqa: E501
        """icons_dual_condition  # noqa: E501

        Returns a forecast icon. Icon services in API are deprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.icons_dual_condition(set, time_of_day, first, second, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str set: . (required)
        :param str time_of_day: . (required)
        :param str first: . (required)
        :param str second: . (required)
        :param Size1 size: Font size
        :param int fontsize: Font size
        :return: BinaryFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.icons_dual_condition_with_http_info(set, time_of_day, first, second, **kwargs)  # noqa: E501
        else:
            (data) = self.icons_dual_condition_with_http_info(set, time_of_day, first, second, **kwargs)  # noqa: E501
            return data

    def icons_dual_condition_with_http_info(self, set, time_of_day, first, second, **kwargs):  # noqa: E501
        """icons_dual_condition  # noqa: E501

        Returns a forecast icon. Icon services in API are deprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.icons_dual_condition_with_http_info(set, time_of_day, first, second, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str set: . (required)
        :param str time_of_day: . (required)
        :param str first: . (required)
        :param str second: . (required)
        :param Size1 size: Font size
        :param int fontsize: Font size
        :return: BinaryFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set', 'time_of_day', 'first', 'second', 'size', 'fontsize']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method icons_dual_condition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set' is set
        if ('set' not in params or
                params['set'] is None):
            raise ValueError("Missing the required parameter `set` when calling `icons_dual_condition`")  # noqa: E501
        # verify the required parameter 'time_of_day' is set
        if ('time_of_day' not in params or
                params['time_of_day'] is None):
            raise ValueError("Missing the required parameter `time_of_day` when calling `icons_dual_condition`")  # noqa: E501
        # verify the required parameter 'first' is set
        if ('first' not in params or
                params['first'] is None):
            raise ValueError("Missing the required parameter `first` when calling `icons_dual_condition`")  # noqa: E501
        # verify the required parameter 'second' is set
        if ('second' not in params or
                params['second'] is None):
            raise ValueError("Missing the required parameter `second` when calling `icons_dual_condition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'set' in params:
            path_params['set'] = params['set']  # noqa: E501
        if 'time_of_day' in params:
            path_params['timeOfDay'] = params['time_of_day']  # noqa: E501
        if 'first' in params:
            path_params['first'] = params['first']  # noqa: E501
        if 'second' in params:
            path_params['second'] = params['second']  # noqa: E501

        query_params = []
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'fontsize' in params:
            query_params.append(('fontsize', params['fontsize']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/icons/{set}/{timeOfDay}/{first}/{second}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BinaryFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def icons_summary(self, **kwargs):  # noqa: E501
        """icons_summary  # noqa: E501

        Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.icons_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.icons_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.icons_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def icons_summary_with_http_info(self, **kwargs):  # noqa: E501
        """icons_summary  # noqa: E501

        Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.icons_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method icons_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/icons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def location_products(self, location_id, **kwargs):  # noqa: E501
        """location_products  # noqa: E501

        Returns a list of valid text product types for a given issuance location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.location_products(location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: . (required)
        :return: TextProductTypeCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.location_products_with_http_info(location_id, **kwargs)  # noqa: E501
        else:
            (data) = self.location_products_with_http_info(location_id, **kwargs)  # noqa: E501
            return data

    def location_products_with_http_info(self, location_id, **kwargs):  # noqa: E501
        """location_products  # noqa: E501

        Returns a list of valid text product types for a given issuance location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.location_products_with_http_info(location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str location_id: . (required)
        :return: TextProductTypeCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['location_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method location_products" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'location_id' is set
        if ('location_id' not in params or
                params['location_id'] is None):
            raise ValueError("Missing the required parameter `location_id` when calling `location_products`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'location_id' in params:
            path_params['locationId'] = params['location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/products/locations/{locationId}/types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TextProductTypeCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def obs_station(self, station_id, **kwargs):  # noqa: E501
        """obs_station  # noqa: E501

        Returns metadata about a given observation station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.obs_station(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Observation station ID (required)
        :return: ObservationStationGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.obs_station_with_http_info(station_id, **kwargs)  # noqa: E501
        else:
            (data) = self.obs_station_with_http_info(station_id, **kwargs)  # noqa: E501
            return data

    def obs_station_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """obs_station  # noqa: E501

        Returns metadata about a given observation station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.obs_station_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Observation station ID (required)
        :return: ObservationStationGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['station_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method obs_station" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'station_id' is set
        if ('station_id' not in params or
                params['station_id'] is None):
            raise ValueError("Missing the required parameter `station_id` when calling `obs_station`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in params:
            path_params['stationId'] = params['station_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObservationStationGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def obs_stations(self, **kwargs):  # noqa: E501
        """obs_stations  # noqa: E501

        Returns a list of observation stations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.obs_stations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] id: Filter by observation station ID
        :param list[AreaCode] state: Filter by state/marine area code
        :param int limit: Limit
        :return: ObservationStationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.obs_stations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.obs_stations_with_http_info(**kwargs)  # noqa: E501
            return data

    def obs_stations_with_http_info(self, **kwargs):  # noqa: E501
        """obs_stations  # noqa: E501

        Returns a list of observation stations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.obs_stations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] id: Filter by observation station ID
        :param list[AreaCode] state: Filter by state/marine area code
        :param int limit: Limit
        :return: ObservationStationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'state', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method obs_stations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
            collection_formats['id'] = 'csv'  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
            collection_formats['state'] = 'csv'  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObservationStationCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def office(self, office_id, **kwargs):  # noqa: E501
        """office  # noqa: E501

        Returns metadata about a NWS forecast office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.office(office_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId office_id: NWS forecast office ID (required)
        :return: Office
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.office_with_http_info(office_id, **kwargs)  # noqa: E501
        else:
            (data) = self.office_with_http_info(office_id, **kwargs)  # noqa: E501
            return data

    def office_with_http_info(self, office_id, **kwargs):  # noqa: E501
        """office  # noqa: E501

        Returns metadata about a NWS forecast office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.office_with_http_info(office_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId office_id: NWS forecast office ID (required)
        :return: Office
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['office_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method office" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'office_id' is set
        if ('office_id' not in params or
                params['office_id'] is None):
            raise ValueError("Missing the required parameter `office_id` when calling `office`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'office_id' in params:
            path_params['officeId'] = params['office_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/offices/{officeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Office',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def office_headline(self, office_id, headline_id, **kwargs):  # noqa: E501
        """office_headline  # noqa: E501

        Returns a specific news headline for a given NWS office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.office_headline(office_id, headline_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId office_id: NWS forecast office ID (required)
        :param str headline_id: Headline record ID (required)
        :return: OfficeHeadline
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.office_headline_with_http_info(office_id, headline_id, **kwargs)  # noqa: E501
        else:
            (data) = self.office_headline_with_http_info(office_id, headline_id, **kwargs)  # noqa: E501
            return data

    def office_headline_with_http_info(self, office_id, headline_id, **kwargs):  # noqa: E501
        """office_headline  # noqa: E501

        Returns a specific news headline for a given NWS office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.office_headline_with_http_info(office_id, headline_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId office_id: NWS forecast office ID (required)
        :param str headline_id: Headline record ID (required)
        :return: OfficeHeadline
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['office_id', 'headline_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method office_headline" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'office_id' is set
        if ('office_id' not in params or
                params['office_id'] is None):
            raise ValueError("Missing the required parameter `office_id` when calling `office_headline`")  # noqa: E501
        # verify the required parameter 'headline_id' is set
        if ('headline_id' not in params or
                params['headline_id'] is None):
            raise ValueError("Missing the required parameter `headline_id` when calling `office_headline`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'office_id' in params:
            path_params['officeId'] = params['office_id']  # noqa: E501
        if 'headline_id' in params:
            path_params['headlineId'] = params['headline_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/offices/{officeId}/headlines/{headlineId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfficeHeadline',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def office_headlines(self, office_id, **kwargs):  # noqa: E501
        """office_headlines  # noqa: E501

        Returns a list of news headlines for a given NWS office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.office_headlines(office_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId office_id: NWS forecast office ID (required)
        :return: OfficeHeadlineCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.office_headlines_with_http_info(office_id, **kwargs)  # noqa: E501
        else:
            (data) = self.office_headlines_with_http_info(office_id, **kwargs)  # noqa: E501
            return data

    def office_headlines_with_http_info(self, office_id, **kwargs):  # noqa: E501
        """office_headlines  # noqa: E501

        Returns a list of news headlines for a given NWS office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.office_headlines_with_http_info(office_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSForecastOfficeId office_id: NWS forecast office ID (required)
        :return: OfficeHeadlineCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['office_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method office_headlines" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'office_id' is set
        if ('office_id' not in params or
                params['office_id'] is None):
            raise ValueError("Missing the required parameter `office_id` when calling `office_headlines`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'office_id' in params:
            path_params['officeId'] = params['office_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/offices/{officeId}/headlines', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfficeHeadlineCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def point(self, point, **kwargs):  # noqa: E501
        """point  # noqa: E501

        Returns metadata about a given latitude/longitude point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.point(point, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PointString point: Point (latitude, longitude) (required)
        :return: PointGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.point_with_http_info(point, **kwargs)  # noqa: E501
        else:
            (data) = self.point_with_http_info(point, **kwargs)  # noqa: E501
            return data

    def point_with_http_info(self, point, **kwargs):  # noqa: E501
        """point  # noqa: E501

        Returns metadata about a given latitude/longitude point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.point_with_http_info(point, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PointString point: Point (latitude, longitude) (required)
        :return: PointGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['point']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method point" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'point' is set
        if ('point' not in params or
                params['point'] is None):
            raise ValueError("Missing the required parameter `point` when calling `point`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'point' in params:
            path_params['point'] = params['point']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/points/{point}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PointGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def point_stations(self, point, **kwargs):  # noqa: E501
        """point_stations  # noqa: E501

        Returns a list of observation stations for a given point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.point_stations(point, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PointString point: Point (latitude, longitude) (required)
        :return: ProblemDetail
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.point_stations_with_http_info(point, **kwargs)  # noqa: E501
        else:
            (data) = self.point_stations_with_http_info(point, **kwargs)  # noqa: E501
            return data

    def point_stations_with_http_info(self, point, **kwargs):  # noqa: E501
        """point_stations  # noqa: E501

        Returns a list of observation stations for a given point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.point_stations_with_http_info(point, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PointString point: Point (latitude, longitude) (required)
        :return: ProblemDetail
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['point']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method point_stations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'point' is set
        if ('point' not in params or
                params['point'] is None):
            raise ValueError("Missing the required parameter `point` when calling `point_stations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'point' in params:
            path_params['point'] = params['point']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/points/{point}/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProblemDetail',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def product(self, product_id, **kwargs):  # noqa: E501
        """product  # noqa: E501

        Returns a specific text product  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product(product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str product_id: . (required)
        :return: TextProduct
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.product_with_http_info(product_id, **kwargs)  # noqa: E501
        else:
            (data) = self.product_with_http_info(product_id, **kwargs)  # noqa: E501
            return data

    def product_with_http_info(self, product_id, **kwargs):  # noqa: E501
        """product  # noqa: E501

        Returns a specific text product  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_with_http_info(product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str product_id: . (required)
        :return: TextProduct
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['product_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method product" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'product_id' is set
        if ('product_id' not in params or
                params['product_id'] is None):
            raise ValueError("Missing the required parameter `product_id` when calling `product`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'product_id' in params:
            path_params['productId'] = params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/products/{productId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TextProduct',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def product_locations(self, **kwargs):  # noqa: E501
        """product_locations  # noqa: E501

        Returns a list of valid text product issuance locations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_locations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TextProductLocationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.product_locations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.product_locations_with_http_info(**kwargs)  # noqa: E501
            return data

    def product_locations_with_http_info(self, **kwargs):  # noqa: E501
        """product_locations  # noqa: E501

        Returns a list of valid text product issuance locations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_locations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TextProductLocationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method product_locations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/products/locations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TextProductLocationCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def product_types(self, **kwargs):  # noqa: E501
        """product_types  # noqa: E501

        Returns a list of valid text product types and codes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TextProductTypeCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.product_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.product_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def product_types_with_http_info(self, **kwargs):  # noqa: E501
        """product_types  # noqa: E501

        Returns a list of valid text product types and codes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.product_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TextProductTypeCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method product_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/products/types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TextProductTypeCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def products_query(self, **kwargs):  # noqa: E501
        """products_query  # noqa: E501

        Returns a list of text products  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.products_query(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] location: Location id
        :param datetime start: Start time
        :param datetime end: End time
        :param list[str] office: Issuing office
        :param list[str] wmoid: WMO id code
        :param list[str] type: Product code
        :param int limit: Limit
        :return: TextProductCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.products_query_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.products_query_with_http_info(**kwargs)  # noqa: E501
            return data

    def products_query_with_http_info(self, **kwargs):  # noqa: E501
        """products_query  # noqa: E501

        Returns a list of text products  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.products_query_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] location: Location id
        :param datetime start: Start time
        :param datetime end: End time
        :param list[str] office: Issuing office
        :param list[str] wmoid: WMO id code
        :param list[str] type: Product code
        :param int limit: Limit
        :return: TextProductCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['location', 'start', 'end', 'office', 'wmoid', 'type', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_query" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'location' in params:
            query_params.append(('location', params['location']))  # noqa: E501
            collection_formats['location'] = 'csv'  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'office' in params:
            query_params.append(('office', params['office']))  # noqa: E501
            collection_formats['office'] = 'csv'  # noqa: E501
        if 'wmoid' in params:
            query_params.append(('wmoid', params['wmoid']))  # noqa: E501
            collection_formats['wmoid'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
            collection_formats['type'] = 'csv'  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/products', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TextProductCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def products_type(self, type_id, **kwargs):  # noqa: E501
        """products_type  # noqa: E501

        Returns a list of text products of a given type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.products_type(type_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type_id: . (required)
        :return: TextProductCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.products_type_with_http_info(type_id, **kwargs)  # noqa: E501
        else:
            (data) = self.products_type_with_http_info(type_id, **kwargs)  # noqa: E501
            return data

    def products_type_with_http_info(self, type_id, **kwargs):  # noqa: E501
        """products_type  # noqa: E501

        Returns a list of text products of a given type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.products_type_with_http_info(type_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type_id: . (required)
        :return: TextProductCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type_id' is set
        if ('type_id' not in params or
                params['type_id'] is None):
            raise ValueError("Missing the required parameter `type_id` when calling `products_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type_id' in params:
            path_params['typeId'] = params['type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/products/types/{typeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TextProductCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def products_type_location(self, type_id, location_id, **kwargs):  # noqa: E501
        """products_type_location  # noqa: E501

        Returns a list of text products of a given type for a given issuance location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.products_type_location(type_id, location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type_id: . (required)
        :param str location_id: . (required)
        :return: TextProductCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.products_type_location_with_http_info(type_id, location_id, **kwargs)  # noqa: E501
        else:
            (data) = self.products_type_location_with_http_info(type_id, location_id, **kwargs)  # noqa: E501
            return data

    def products_type_location_with_http_info(self, type_id, location_id, **kwargs):  # noqa: E501
        """products_type_location  # noqa: E501

        Returns a list of text products of a given type for a given issuance location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.products_type_location_with_http_info(type_id, location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type_id: . (required)
        :param str location_id: . (required)
        :return: TextProductCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type_id', 'location_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_type_location" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type_id' is set
        if ('type_id' not in params or
                params['type_id'] is None):
            raise ValueError("Missing the required parameter `type_id` when calling `products_type_location`")  # noqa: E501
        # verify the required parameter 'location_id' is set
        if ('location_id' not in params or
                params['location_id'] is None):
            raise ValueError("Missing the required parameter `location_id` when calling `products_type_location`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type_id' in params:
            path_params['typeId'] = params['type_id']  # noqa: E501
        if 'location_id' in params:
            path_params['locationId'] = params['location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/products/types/{typeId}/locations/{locationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TextProductCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def products_type_locations(self, type_id, **kwargs):  # noqa: E501
        """products_type_locations  # noqa: E501

        Returns a list of valid text product issuance locations for a given product type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.products_type_locations(type_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type_id: . (required)
        :return: TextProductLocationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.products_type_locations_with_http_info(type_id, **kwargs)  # noqa: E501
        else:
            (data) = self.products_type_locations_with_http_info(type_id, **kwargs)  # noqa: E501
            return data

    def products_type_locations_with_http_info(self, type_id, **kwargs):  # noqa: E501
        """products_type_locations  # noqa: E501

        Returns a list of valid text product issuance locations for a given product type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.products_type_locations_with_http_info(type_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type_id: . (required)
        :return: TextProductLocationCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_type_locations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type_id' is set
        if ('type_id' not in params or
                params['type_id'] is None):
            raise ValueError("Missing the required parameter `type_id` when calling `products_type_locations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type_id' in params:
            path_params['typeId'] = params['type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/products/types/{typeId}/locations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TextProductLocationCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def radar_profiler(self, station_id, **kwargs):  # noqa: E501
        """radar_profiler  # noqa: E501

        Returns metadata about a given radar wind profiler  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_profiler(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Profiler station ID (required)
        :param ISO8601Interval time: Time interval
        :param ISO8601Duration interval: Averaging interval
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.radar_profiler_with_http_info(station_id, **kwargs)  # noqa: E501
        else:
            (data) = self.radar_profiler_with_http_info(station_id, **kwargs)  # noqa: E501
            return data

    def radar_profiler_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """radar_profiler  # noqa: E501

        Returns metadata about a given radar wind profiler  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_profiler_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Profiler station ID (required)
        :param ISO8601Interval time: Time interval
        :param ISO8601Duration interval: Averaging interval
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['station_id', 'time', 'interval']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_profiler" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'station_id' is set
        if ('station_id' not in params or
                params['station_id'] is None):
            raise ValueError("Missing the required parameter `station_id` when calling `radar_profiler`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in params:
            path_params['stationId'] = params['station_id']  # noqa: E501

        query_params = []
        if 'time' in params:
            query_params.append(('time', params['time']))  # noqa: E501
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/radar/profilers/{stationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def radar_queue(self, host, **kwargs):  # noqa: E501
        """radar_queue  # noqa: E501

        Returns metadata about a given radar queue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_queue(host, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str host: LDM host (required)
        :param int limit: Record limit
        :param ISO8601Interval arrived: Range for arrival time
        :param ISO8601Interval created: Range for creation time
        :param ISO8601Interval published: Range for publish time
        :param str station: Station identifier
        :param str type: Record type
        :param str feed: Originating product feed
        :param int resolution: Resolution version
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.radar_queue_with_http_info(host, **kwargs)  # noqa: E501
        else:
            (data) = self.radar_queue_with_http_info(host, **kwargs)  # noqa: E501
            return data

    def radar_queue_with_http_info(self, host, **kwargs):  # noqa: E501
        """radar_queue  # noqa: E501

        Returns metadata about a given radar queue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_queue_with_http_info(host, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str host: LDM host (required)
        :param int limit: Record limit
        :param ISO8601Interval arrived: Range for arrival time
        :param ISO8601Interval created: Range for creation time
        :param ISO8601Interval published: Range for publish time
        :param str station: Station identifier
        :param str type: Record type
        :param str feed: Originating product feed
        :param int resolution: Resolution version
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['host', 'limit', 'arrived', 'created', 'published', 'station', 'type', 'feed', 'resolution']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_queue" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'host' is set
        if ('host' not in params or
                params['host'] is None):
            raise ValueError("Missing the required parameter `host` when calling `radar_queue`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'host' in params:
            path_params['host'] = params['host']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'arrived' in params:
            query_params.append(('arrived', params['arrived']))  # noqa: E501
        if 'created' in params:
            query_params.append(('created', params['created']))  # noqa: E501
        if 'published' in params:
            query_params.append(('published', params['published']))  # noqa: E501
        if 'station' in params:
            query_params.append(('station', params['station']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'feed' in params:
            query_params.append(('feed', params['feed']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/radar/queues/{host}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def radar_server(self, id, **kwargs):  # noqa: E501
        """radar_server  # noqa: E501

        Returns metadata about a given radar server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_server(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Server ID (required)
        :param str reporting_host: Show records from specific reporting host
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.radar_server_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.radar_server_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def radar_server_with_http_info(self, id, **kwargs):  # noqa: E501
        """radar_server  # noqa: E501

        Returns metadata about a given radar server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_server_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Server ID (required)
        :param str reporting_host: Show records from specific reporting host
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'reporting_host']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `radar_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reporting_host' in params:
            query_params.append(('reportingHost', params['reporting_host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/radar/servers/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def radar_servers(self, **kwargs):  # noqa: E501
        """radar_servers  # noqa: E501

        Returns a list of radar servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_servers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reporting_host: Show records from specific reporting host
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.radar_servers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.radar_servers_with_http_info(**kwargs)  # noqa: E501
            return data

    def radar_servers_with_http_info(self, **kwargs):  # noqa: E501
        """radar_servers  # noqa: E501

        Returns a list of radar servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_servers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reporting_host: Show records from specific reporting host
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reporting_host']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_servers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'reporting_host' in params:
            query_params.append(('reportingHost', params['reporting_host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/radar/servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def radar_station(self, station_id, **kwargs):  # noqa: E501
        """radar_station  # noqa: E501

        Returns metadata about a given radar station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_station(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Radar station ID (required)
        :param str reporting_host: Show RDA and latency info from specific reporting host
        :param str host: Show latency info from specific LDM host
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.radar_station_with_http_info(station_id, **kwargs)  # noqa: E501
        else:
            (data) = self.radar_station_with_http_info(station_id, **kwargs)  # noqa: E501
            return data

    def radar_station_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """radar_station  # noqa: E501

        Returns metadata about a given radar station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_station_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Radar station ID (required)
        :param str reporting_host: Show RDA and latency info from specific reporting host
        :param str host: Show latency info from specific LDM host
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['station_id', 'reporting_host', 'host']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_station" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'station_id' is set
        if ('station_id' not in params or
                params['station_id'] is None):
            raise ValueError("Missing the required parameter `station_id` when calling `radar_station`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in params:
            path_params['stationId'] = params['station_id']  # noqa: E501

        query_params = []
        if 'reporting_host' in params:
            query_params.append(('reportingHost', params['reporting_host']))  # noqa: E501
        if 'host' in params:
            query_params.append(('host', params['host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/radar/stations/{stationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def radar_station_alarms(self, station_id, **kwargs):  # noqa: E501
        """radar_station_alarms  # noqa: E501

        Returns metadata about a given radar station alarms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_station_alarms(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Radar station ID (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.radar_station_alarms_with_http_info(station_id, **kwargs)  # noqa: E501
        else:
            (data) = self.radar_station_alarms_with_http_info(station_id, **kwargs)  # noqa: E501
            return data

    def radar_station_alarms_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """radar_station_alarms  # noqa: E501

        Returns metadata about a given radar station alarms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_station_alarms_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Radar station ID (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['station_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_station_alarms" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'station_id' is set
        if ('station_id' not in params or
                params['station_id'] is None):
            raise ValueError("Missing the required parameter `station_id` when calling `radar_station_alarms`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in params:
            path_params['stationId'] = params['station_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/radar/stations/{stationId}/alarms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def radar_stations(self, **kwargs):  # noqa: E501
        """radar_stations  # noqa: E501

        Returns a list of radar stations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_stations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] station_type: Limit results to a specific station type or types
        :param str reporting_host: Show RDA and latency info from specific reporting host
        :param str host: Show latency info from specific LDM host
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.radar_stations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.radar_stations_with_http_info(**kwargs)  # noqa: E501
            return data

    def radar_stations_with_http_info(self, **kwargs):  # noqa: E501
        """radar_stations  # noqa: E501

        Returns a list of radar stations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.radar_stations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] station_type: Limit results to a specific station type or types
        :param str reporting_host: Show RDA and latency info from specific reporting host
        :param str host: Show latency info from specific LDM host
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['station_type', 'reporting_host', 'host']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_stations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'station_type' in params:
            query_params.append(('stationType', params['station_type']))  # noqa: E501
            collection_formats['stationType'] = 'csv'  # noqa: E501
        if 'reporting_host' in params:
            query_params.append(('reportingHost', params['reporting_host']))  # noqa: E501
        if 'host' in params:
            query_params.append(('host', params['host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/radar/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def satellite_thumbnails(self, area, **kwargs):  # noqa: E501
        """satellite_thumbnails  # noqa: E501

        Returns a thumbnail image for a satellite region. Image services in API are deprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.satellite_thumbnails(area, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str area: . (required)
        :return: BinaryFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.satellite_thumbnails_with_http_info(area, **kwargs)  # noqa: E501
        else:
            (data) = self.satellite_thumbnails_with_http_info(area, **kwargs)  # noqa: E501
            return data

    def satellite_thumbnails_with_http_info(self, area, **kwargs):  # noqa: E501
        """satellite_thumbnails  # noqa: E501

        Returns a thumbnail image for a satellite region. Image services in API are deprecated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.satellite_thumbnails_with_http_info(area, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str area: . (required)
        :return: BinaryFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['area']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method satellite_thumbnails" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'area' is set
        if ('area' not in params or
                params['area'] is None):
            raise ValueError("Missing the required parameter `area` when calling `satellite_thumbnails`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'area' in params:
            path_params['area'] = params['area']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/jpeg', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/thumbnails/satellite/{area}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BinaryFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def station_observation_latest(self, station_id, **kwargs):  # noqa: E501
        """station_observation_latest  # noqa: E501

        Returns the latest observation for a station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.station_observation_latest(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Observation station ID (required)
        :param bool require_qc: Require QC
        :return: ObservationGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.station_observation_latest_with_http_info(station_id, **kwargs)  # noqa: E501
        else:
            (data) = self.station_observation_latest_with_http_info(station_id, **kwargs)  # noqa: E501
            return data

    def station_observation_latest_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """station_observation_latest  # noqa: E501

        Returns the latest observation for a station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.station_observation_latest_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Observation station ID (required)
        :param bool require_qc: Require QC
        :return: ObservationGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['station_id', 'require_qc']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method station_observation_latest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'station_id' is set
        if ('station_id' not in params or
                params['station_id'] is None):
            raise ValueError("Missing the required parameter `station_id` when calling `station_observation_latest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in params:
            path_params['stationId'] = params['station_id']  # noqa: E501

        query_params = []
        if 'require_qc' in params:
            query_params.append(('require_qc', params['require_qc']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.obs+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}/observations/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObservationGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def station_observation_list(self, station_id, **kwargs):  # noqa: E501
        """station_observation_list  # noqa: E501

        Returns a list of observations for a given station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.station_observation_list(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Observation station ID (required)
        :param datetime start: Start time
        :param datetime end: End time
        :param int limit: Limit
        :return: ObservationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.station_observation_list_with_http_info(station_id, **kwargs)  # noqa: E501
        else:
            (data) = self.station_observation_list_with_http_info(station_id, **kwargs)  # noqa: E501
            return data

    def station_observation_list_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """station_observation_list  # noqa: E501

        Returns a list of observations for a given station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.station_observation_list_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Observation station ID (required)
        :param datetime start: Start time
        :param datetime end: End time
        :param int limit: Limit
        :return: ObservationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['station_id', 'start', 'end', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method station_observation_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'station_id' is set
        if ('station_id' not in params or
                params['station_id'] is None):
            raise ValueError("Missing the required parameter `station_id` when calling `station_observation_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in params:
            path_params['stationId'] = params['station_id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}/observations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObservationCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def station_observation_time(self, station_id, time, **kwargs):  # noqa: E501
        """station_observation_time  # noqa: E501

        Returns a single observation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.station_observation_time(station_id, time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Observation station ID (required)
        :param datetime time: Timestamp of requested observation (required)
        :return: ObservationGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.station_observation_time_with_http_info(station_id, time, **kwargs)  # noqa: E501
        else:
            (data) = self.station_observation_time_with_http_info(station_id, time, **kwargs)  # noqa: E501
            return data

    def station_observation_time_with_http_info(self, station_id, time, **kwargs):  # noqa: E501
        """station_observation_time  # noqa: E501

        Returns a single observation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.station_observation_time_with_http_info(station_id, time, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str station_id: Observation station ID (required)
        :param datetime time: Timestamp of requested observation (required)
        :return: ObservationGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['station_id', 'time']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method station_observation_time" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'station_id' is set
        if ('station_id' not in params or
                params['station_id'] is None):
            raise ValueError("Missing the required parameter `station_id` when calling `station_observation_time`")  # noqa: E501
        # verify the required parameter 'time' is set
        if ('time' not in params or
                params['time'] is None):
            raise ValueError("Missing the required parameter `time` when calling `station_observation_time`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in params:
            path_params['stationId'] = params['station_id']  # noqa: E501
        if 'time' in params:
            path_params['time'] = params['time']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.obs+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}/observations/{time}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObservationGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def zone(self, type, zone_id, **kwargs):  # noqa: E501
        """zone  # noqa: E501

        Returns metadata about a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone(type, zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Zone type (required)
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :param datetime effective: Effective date/time
        :return: ZoneGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.zone_with_http_info(type, zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.zone_with_http_info(type, zone_id, **kwargs)  # noqa: E501
            return data

    def zone_with_http_info(self, type, zone_id, **kwargs):  # noqa: E501
        """zone  # noqa: E501

        Returns metadata about a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_with_http_info(type, zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Zone type (required)
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :param datetime effective: Effective date/time
        :return: ZoneGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'zone_id', 'effective']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `zone`")  # noqa: E501
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'zone_id' in params:
            path_params['zoneId'] = params['zone_id']  # noqa: E501

        query_params = []
        if 'effective' in params:
            query_params.append(('effective', params['effective']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/zones/{type}/{zoneId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZoneGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def zone_forecast(self, type, zone_id, **kwargs):  # noqa: E501
        """zone_forecast  # noqa: E501

        Returns the current zone forecast for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_forecast(type, zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Zone type (required)
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :return: ZoneForecastGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.zone_forecast_with_http_info(type, zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.zone_forecast_with_http_info(type, zone_id, **kwargs)  # noqa: E501
            return data

    def zone_forecast_with_http_info(self, type, zone_id, **kwargs):  # noqa: E501
        """zone_forecast  # noqa: E501

        Returns the current zone forecast for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_forecast_with_http_info(type, zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Zone type (required)
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :return: ZoneForecastGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'zone_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zone_forecast" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `zone_forecast`")  # noqa: E501
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `zone_forecast`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'zone_id' in params:
            path_params['zoneId'] = params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/zones/{type}/{zoneId}/forecast', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZoneForecastGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def zone_list(self, **kwargs):  # noqa: E501
        """zone_list  # noqa: E501

        Returns a list of zones  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[NWSZoneID] id: Zone ID (forecast or county)
        :param list[AreaCode] area: State/marine area code
        :param list[RegionCode] region: Region code
        :param list[str] type: Zone type
        :param PointString point: Point (latitude,longitude)
        :param bool include_geometry: Include geometry in results (true/false)
        :param int limit: Limit
        :param datetime effective: Effective date/time
        :return: ZoneCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.zone_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.zone_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def zone_list_with_http_info(self, **kwargs):  # noqa: E501
        """zone_list  # noqa: E501

        Returns a list of zones  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[NWSZoneID] id: Zone ID (forecast or county)
        :param list[AreaCode] area: State/marine area code
        :param list[RegionCode] region: Region code
        :param list[str] type: Zone type
        :param PointString point: Point (latitude,longitude)
        :param bool include_geometry: Include geometry in results (true/false)
        :param int limit: Limit
        :param datetime effective: Effective date/time
        :return: ZoneCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'area', 'region', 'type', 'point', 'include_geometry', 'limit', 'effective']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zone_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
            collection_formats['id'] = 'csv'  # noqa: E501
        if 'area' in params:
            query_params.append(('area', params['area']))  # noqa: E501
            collection_formats['area'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
            collection_formats['type'] = 'csv'  # noqa: E501
        if 'point' in params:
            query_params.append(('point', params['point']))  # noqa: E501
        if 'include_geometry' in params:
            query_params.append(('include_geometry', params['include_geometry']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'effective' in params:
            query_params.append(('effective', params['effective']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/zones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZoneCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def zone_list_type(self, type, **kwargs):  # noqa: E501
        """zone_list_type  # noqa: E501

        Returns a list of zones of a given type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_list_type(type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Zone type (required)
        :param list[NWSZoneID] id: Zone ID (forecast or county)
        :param list[AreaCode] area: State/marine area code
        :param list[RegionCode] region: Region code
        :param list[str] type: Zone type
        :param PointString point: Point (latitude,longitude)
        :param bool include_geometry: Include geometry in results (true/false)
        :param int limit: Limit
        :param datetime effective: Effective date/time
        :return: ZoneCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.zone_list_type_with_http_info(type, **kwargs)  # noqa: E501
        else:
            (data) = self.zone_list_type_with_http_info(type, **kwargs)  # noqa: E501
            return data

    def zone_list_type_with_http_info(self, type, **kwargs):  # noqa: E501
        """zone_list_type  # noqa: E501

        Returns a list of zones of a given type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_list_type_with_http_info(type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Zone type (required)
        :param list[NWSZoneID] id: Zone ID (forecast or county)
        :param list[AreaCode] area: State/marine area code
        :param list[RegionCode] region: Region code
        :param list[str] type: Zone type
        :param PointString point: Point (latitude,longitude)
        :param bool include_geometry: Include geometry in results (true/false)
        :param int limit: Limit
        :param datetime effective: Effective date/time
        :return: ZoneCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'id', 'area', 'region', 'type', 'point', 'include_geometry', 'limit', 'effective']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zone_list_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `zone_list_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
            collection_formats['id'] = 'csv'  # noqa: E501
        if 'area' in params:
            query_params.append(('area', params['area']))  # noqa: E501
            collection_formats['area'] = 'csv'  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'point' in params:
            query_params.append(('point', params['point']))  # noqa: E501
        if 'include_geometry' in params:
            query_params.append(('include_geometry', params['include_geometry']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'effective' in params:
            query_params.append(('effective', params['effective']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/zones/{type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ZoneCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def zone_obs(self, zone_id, **kwargs):  # noqa: E501
        """zone_obs  # noqa: E501

        Returns a list of observations for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_obs(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :param datetime start: Start date/time
        :param datetime end: End date/time
        :param int limit: Limit
        :return: ObservationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.zone_obs_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.zone_obs_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def zone_obs_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """zone_obs  # noqa: E501

        Returns a list of observations for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_obs_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :param datetime start: Start date/time
        :param datetime end: End date/time
        :param int limit: Limit
        :return: ObservationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id', 'start', 'end', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zone_obs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `zone_obs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zoneId'] = params['zone_id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/zones/forecast/{zoneId}/observations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObservationCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def zone_stations(self, zone_id, **kwargs):  # noqa: E501
        """zone_stations  # noqa: E501

        Returns a list of observation stations for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_stations(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :return: ObservationStationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.zone_stations_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.zone_stations_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def zone_stations_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """zone_stations  # noqa: E501

        Returns a list of observation stations for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zone_stations_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NWSZoneID zone_id: NWS public zone/county identifier (required)
        :return: ObservationStationCollectionGeoJson
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zone_stations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `zone_stations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zoneId'] = params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['userAgent']  # noqa: E501

        return self.api_client.call_api(
            '/zones/forecast/{zoneId}/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObservationStationCollectionGeoJson',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
